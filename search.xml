<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CSS易混淆点小总结]]></title>
      <url>%2F2017%2F03%2F12%2F20170312-CSS-Study-CSS-Layout%2F</url>
      <content type="text"><![CDATA[总结包含以下内容：CSS hack、清除浮动(clearfix hack)、CSS伪类和伪元素、Box-Sizing、水平居中和垂直居中、em和rem的区别、max-width、@media媒体查询、columns、@import加载CSS文件和link的区别、使用CDN、Flex布局 CSS hack因为不同浏览器对CSS的兼容不同，所以需要hack来对CSS做一些兼容。常用的有四种方法： 条件注释法 在使用Bootstrap时，经常可以在&lt;head&gt;&lt;/head&gt;中看到有以下这段： 1234&lt;!--[if lt IE 9]&gt; &lt;script src="https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js"&gt;&lt;/script&gt; &lt;script src="https://cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 这就是条件注释法，把其中的内容换成link链接即可。条件注释法还有兼容其它IE浏览器的写法： 12345678910&lt;!--[if !IE]&gt; 除IE外都可识别&lt;![endif]--&gt;&lt;!--[if IE]&gt; 所有的IE可识别 &lt;![endif]--&gt;&lt;!--[if IE 6]&gt; 仅IE6可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 6]&gt; IE6以及IE6以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 6]&gt; IE6以及IE6以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt; 仅IE7可识别 &lt;![endif]--&gt;&lt;!--[if lt IE 7]&gt; IE7以及IE7以下版本可识别 &lt;![endif]--&gt;&lt;!--[if gte IE 7]&gt; IE7以及IE7以上版本可识别 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt; 仅IE8可识别 &lt;![endif]--&gt;&lt;!--[if IE 9]&gt; 仅IE9可识别 &lt;![endif]--&gt; 正确的CSS hack的一种写法是： 12&lt;link rel="stylesheet" type="text/css" href="css1.css" /&gt;&lt;!--[if lt IE 9]&gt;&lt;link rel="stylesheet" type="text/css" href="css2.css" /&gt;&lt;![endif]--&gt; 解释一下最上方的Bootstrap代码： html5shiv主要解决HTML5提出的新的元素不被IE6-8识别，这些新元素不能作为父节点包裹子元素，并且不能应用CSS样式。让CSS 样式应用在未知元素上只需执行 document.createElement(elementName) 即可实现。html5shiv就是根据这个原理创建的 引入respond.js，让低浏览器支持css3的新属性，比如@media媒体查询的使用。使用respond.js注意以下几点： Respond.js 与 跨域（cross-domain） CSS 的问题，解决方法：样式文件跨域导致Respond.js插件在IE浏览器失效的问题 Respond.js 与 file:// 协议，由于浏览器的安全机制，Respond.js 不能在通过 file:// 协议（打开本地HTML文件所用的协议）访问的页面上发挥正常的功能。如果需要测试 IE8 下面的响应式特性，务必通过 http 协议访问页面（例如搭建 apache、nginx 等）。 Respond.js 与 @import 指令，Respond.js不支持通过 @import指令所引入的 CSS 文件。 类内属性前缀法在CSS样式属性名前加上一些只有特定浏览器才能识别的hack前缀，以达到预期的页面展现效果比如： 1background-color:blue !important;/* All browsers but IE6 */ 选择器前缀法比如\*html， \*前缀只对IE6生效 CSS3选择器结合JavaScript的Hack 以上更详细的解释，请点击史上最全的CSS hack方式一览 参考资料 条件注释判断浏览器版本 Html5shiv Bootsrap对浏览器和设备的支持情况 史上最全的CSS hack方式一览 清除浮动(clearfix hack)以下是Bootsrap下的写法123456789101112.clearfix &#123; zoom: 1; &#125; .clearfix:before, .clearfix:after &#123; display: table; line-height: 0; content: ""; &#125; .clearfix:after &#123; clear: both; &#125; 奇舞团的老师在慕课网上讲课时，使用的是以下的方法12345678910.clearfix:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden;&#125;.clearfix &#123;display: inline-block;&#125;* html .clearfix &#123;height: 1%;&#125;.clearfix &#123;display: block;&#125; 更详细的clearfix hack，请点击What methods of ‘clearfix’ can I use?。但肯定的是，为了不破坏HTML的文档结构，clearfix hack要使用CSS的伪元素:before和:after 参考资料 What methods of ‘clearfix’ can I use? CSS伪类和伪元素1.:after/::after和:before/::before都是CSS伪元素，与:hover/:active等伪类不一样。2.:before/:after伪元素是在CSS2中提出来的，所以兼容性到IE8了。3.::before/::after是CSS3中的写法，为了将伪类和伪元素区分开。但是平时为了兼容性，还是会用一个冒号的写法 想了解更多，请点击CSS 伪元素和CSS 伪类 关于伪类:before和:after中content的内容 [String]，使用引号包括一段字符串，将会向元素内容中添加字符串。示例： 1a:after &#123; content: "↗"; &#125; attr()，调用当前元素的属性，可以方便的比如将图片的 Alt 提示文字或者链接的 Href 地址显示出来。示例： 123a:after &#123; content:"(" attr(href) ")"; &#125; url()或uri()，用于引用媒体文件。示例： 123h1:before &#123; content: url(logo.png); &#125; counter()，调用计数器，可以不使用列表元素实现序号功能。具体请参见 counter-increment 和 counter-reset 属性的用法。示例： 1234h2:before &#123; counter-increment: chapter; content: "Chapter " counter(chapter) ". " &#125; 伪类元素:nth-child() 和:nth-of-type() :nth-child():做手机网站的时候，由于手机网站对浏览器兼容要求相对较低，手机浏览器大部分都支持css3，这就大大提高了开发效率。可以随意使用CSS3:nth-child()伪类选择器。IE9及以上版本，火狐，谷歌，Safari ，Opera都支持:nth-child() :nth-child(n)与:nth-of-type(n)的区别 ele:nth-child(n) 选择器匹配属于其父元素的第n个子元素，不论元素的类型。n 可以是数字、关键词或公式。比如ele:nth-child(odd),即匹配序号为奇数的元素 ele:nth-of-type(n) 选择器的意思是“规定属于其父元素的第n个ele元素” 参考资料 :after/::after和:before/::before的区别 谈谈css的伪类和伪元素 CSS3的nth-child()选择器 Box-Sizing box-sizing属性可以为三个值之一：content-box（default），border-box，padding-boxcontent-box，border和padding不计算入width之内padding-box，padding计算入width内border-box，border和padding计算入width之内，其实就是怪异模式了 ie8+浏览器支持content-box和border-box，ff则支持全部三个值 个人推荐使用border-box，因为padding-box只能在ff中得到支持 参考资料 css3 box-sizing属性 水平居中和垂直居中水平居中和垂直居中要分三种情况来分析，一是display类型，二是单行还是多行居中，三是是否事先知道对象的宽高。更加详细请戳参考资料 参考资料 关于居中一 关于居中二 em和rem的区别 em的参考对象是父级元素 任意浏览器的默认字体高都是16px，为了简化font-size的换算，需要在css中的body选择器中声明 Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了 rem是CSS3新增的一个相对对象，参考对象是HTML对象的根元素 除了IE8及更早版本外，所有浏览器均已支持rem。对于不支持它的浏览器，应对方法也很简单，就是多写一个绝对单位的声明。这些浏览器会忽略用rem设定的字体大小 使用 rem 单位的主要目的应该是确保无论用户如何设置自己的浏览器，我们的布局都能调整到合适大小。 注意不要在多列布局中使用em或rem,改用%。什么时候使用em和rem可以戳一下参考资料链接 参考资料 何时使用 Em 与 Rem max-width使用max-width替代width可以使浏览器更好地处理小窗口的情况。这点在移动设备上显得尤为重要，调整下浏览器窗口大小可以检查一下。顺便提下， 所有的主流浏览器包括IE7+在内都支持max-width所以放心大胆的用吧 @media媒体查询基本格式如以下说示123@media (min-width: 768px)&#123; //&gt;=768的设备 &#125;@media (min-width: 992px)&#123; //&gt;=992的设备 &#125;@media (min-width: 1200)&#123; //&gt;=1200的设备 &#125; 123@media (max-width: 1199)&#123; //&lt;=1199的设备 &#125;@media (max-width: 991px)&#123; //&lt;=991的设备 &#125;@media (max-width: 767px)&#123; //&lt;=768的设备 &#125; 注意大小的顺序，另外也可以这么使用，如以下 123@media screen and (min-width: 960px) and (max-width: 1199px) &#123; #page&#123; width: 960px; &#125;#content,.div1&#123;width: 650px;&#125;#secondary&#123;width:250px&#125;select&#123;max-width:200px&#125;&#125; 使用@media就能做出自适应的布局了 参考资料 利用@media screen实现网页布局的自适应 columns columns是CSS3的新属性，Internet Explorer 9 以及更早版本的浏览器不支持 column 属性。 属性有Column-count(列的数目)、Column-gap(列的间隔)、Column-width(列的宽度)和Column-rule 前缀 -webkit-,-moz- 参考资料 CSS3 columns 属性 @import加载CSS文件和link的区别个人觉得比较重要的五个不同如以下所示： 引用的方式不同link(外部引用): 1&lt;link rel="stylesheet" href="xxx.css" type="text/css" / &gt; @import(导入式):@import url(xxx.css); 放置的位置不同link一般放在head标签中 @import必须放在&lt;style type=&quot;text/css&quot;&gt;标签中 加载内容不同link可以加载除了css文件外，还可以加载MIME类型的文件 当使用 Javascript 控制 DOM 去改变样式的时候，只能使用 link 方式，因为@import眼里只有CSS，不是 DOM 可以控制的； 加载方式不同link会和dom结构一同加载渲染@import只能等dom结构加载完成以后才能渲染页面 参考资料 外部引用css时，link和@import两种区别 使用CDN 什么是CDNCDN的全称是Content Delivery Network，即内容分发网络。是通过在现有的 Internet 中增加一层新的网络架构，将网站的内容发布到最接近用户的网络 “ 边缘 “ ，使用户可以就近取得所需的内容，解决 Internet 网络拥塞状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因，造成的用户访问网站的响应速度慢的问题 使用CDN有利有弊 参考资料 CDN使用心得 Flex布局Flex布局可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。兼容IE10+。了解更多请看下阮一峰老师的教程。 参考资料 Flex 布局教程：语法篇 Flex 布局教程：实例篇]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于arr[i++]与arr[++i]]]></title>
      <url>%2F2017%2F03%2F10%2F20170310-JavaScript-arr%5Bi%2B%2B%5D%2F</url>
      <content type="text"><![CDATA[前言 前几天做Canvas倒计时的时候，慕课网的老师讲到了一个及时清除不在画布中的小球的做法。以下是实现代码： 123456789101112//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//删除前面的数组使用balls.shift()while(balls.length&gt;cnt)&#123; balls.pop();//删除第cnt个到balls.length-1个数组&#125; 一开始挺懵的，arr[i++]是啥，于是开始一步一步地探索 i++和++i大一的时候上java课，老师讲过了这样的题，想必学过计算机相关的都知道&nbsp; &nbsp; 1234567891011var a=1;var b=2;a=b++;console.log("a的值是："+a+"，"+"b的值是："+b);//"a的值是：2，b的值是：3"var c=1;var d=2;c=++d;console.log("c的值是："+c+"，"+"d的值是："+d);//"c的值是：3，d的值是：3" a=b++是b先把值赋给a，自身再加1；a=++b是b先自身加1，再把值赋给a i++和++i&nbsp; 在循环中的区别 i++在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(i++); //依次输出0,2,4&#125; ++i在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(++i); //依次输出1,3,5&#125; 对比以上代码，是不是发现什么了&nbsp; &nbsp; arr[i++]和arr[++i]在循环中的区别 arr[i++]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i++]); //依次输出11,13,15&#125; arr[++i]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[++i]); //依次输出12,14,16&#125; 如果数组是奇数个，那么输出arr[++i]的最后一个数会是一个undefined arr[i++]+=1和arr[++i]+=1在循环中的区别 arr[i++]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[i++]+=1;&#125; console.log(arr);//输出[2,2,4] arr[++i]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[++i]+=1;&#125; console.log(arr);//输出[1,3,3,NaN] 由于数组是奇数个，所以最后arr[++i]+=1最后的输出结果是NaN，可以通过以下的代码验证 12console.log(undefined+1);//输出NaN 好啦，到此为止，是不是理解了arr[i++]和arr[++i]了，现在回到我们的前言了，老师如何清除不符合判断语句的数组 arr[i++]的使用12345678910111213141516171819202122232425262728var arr=[ &#123;x: 1&#125;, &#123;x: 5&#125;, &#123;x: 9&#125;, &#123;x: 3&#125;, &#123;x: 10&#125;, &#123;x: 6&#125;]var cnt=0;for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].x&lt;4)&#123; arr[cnt++]=arr[i]; console.log('cnt的值是'+cnt+'，i的值是'+i); //"cnt的值是1，i的值是0" //"cnt的值是2，i的值是3" &#125; &#125; while(arr.length&gt;cnt)&#123; arr.pop();&#125;console.log(arr);// [// [object Object] &#123;x: 1&#125;, // [object Object] &#123;x: 3&#125;// ] 这说明了第0到cnt-1个留在arr中，cnt到arr.length-1的数组删除，使用这个方法就可以来去除不符合判断语句的数组了，是不是一个很好的技巧呢]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas绚丽倒计时学习笔记]]></title>
      <url>%2F2017%2F03%2F09%2F20170309-Canvas-Countdown%2F</url>
      <content type="text"><![CDATA[演示&nbsp; &nbsp; |&nbsp; &nbsp; 文件&nbsp; &nbsp; |&nbsp; &nbsp;汁源 Foreword 关于Canvas HTML5 &lt;canvas&gt; 标签用于绘制图像（通过脚本，通常是 JavaScript）。不过，&lt;canvas&gt;元素本身并没有绘制能力（它仅仅是图形的容器）， 您必须使用脚本来完成实际的绘图任务。&nbsp;&nbsp;[该叙述来自W3CSCHOOL] Creat Canvas 创建画布 canvas是行内元素，有默认的高宽（300px*150px） display: block可以把&lt;canvas&gt;&lt;/canvas&gt;变成块级元素,从而可以通过margin: 0 auto;设置为水平居中 canvas有显示的大小，还有内里分辨率的大小，所以不能在css中设置canvas的宽高。可以使用以下两种方法设置 12&lt;!--直接在标签头设置--&gt;&lt;canvas width="1024" height="500"&gt;&lt;/canvas&gt; 1234//在js中设置var canvas=document.getElementById('canvas');canvas.width="1024";canvas.height="500"; &lt;canvas&gt;是HTML5的新标签，所以存在兼容问题。注意：若把判断条件改成canvas.getContext(&quot;2d&quot;)会出错 123456if(canvas.getContext)&#123; var context=canvas.getContext('2d'); &#125;else&#123; alert('当前浏览器不支持canvas，请更换浏览器后再试');&#125; Draw Line 绘制直线 以下的context，默认由var context=canvas.getContext(&quot;2d&quot;)取得。 context.closePath()的存在会让未闭合的线条自动闭合，所以用不用看情况。总之，一个Canvas画布如果没有使用context.beginPath()，那么画布上的其它图形会受到影响 context.moveTo(x1,y1)用来定义画笔的起始位置context.lineTo(x2,y2)用来定义画笔的终止位置 1234567//画一个闭合图形context.beginPath();context.moveTo(x1,y1);context.lineTo(x2,y2);context.lineTo(x1,y2);context.moveTo(x1,y1);context.closePath(); context.lineWidth=num定义画笔大小context.strokeStyle=&quot;color&quot;定义画笔颜色context.stroke() 执行绘图的方法context.fillStyle=&quot;color&quot;定义填充的颜色context.fill() 执行着色的方法 使用以上方法，即可绘制一个七巧板： Draw Arc 绘制弧线 context.arc(300,300,0,1.5*Math.PI,false) 的含义是沿顺时针的方向来绘制一个圆心为（300，300），角度为1.5π 12context.arc(centerx,centery,radius,startingAngle,endingAngle,anticlockwise=false);//默认clockwise=false，即在逆时针的方向上以角度为 0,0.5*PI,1*PI,1.5*PI,2*PI这种形式绘图 Draw Digit 绘制静止的时钟 先编写一个三维数组，来显示数字和冒号。这里以0和：来举例 12345678910111213141516171819202122232425262728//数字有7列10行组成，冒号由4列10行组成，数组中有1的地方就是代表有小球digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ]; 通过循环数组，定义好小球之间的距离，即可画出小球。不过说得容易，逻辑对我们这些初学者有点小复杂。感兴趣可以看下我github上的文件：drawDigit.js Countdown Effect 设置倒计时效果 获取倒计时的时间使用设置好的时间减去现在的时间，这个设置好的时间可以使用new Date()生成，比如const endTime=new Date(2017,2,7,20,14,12)。其中月份是从0开始的，所以这个时间的含义是2017-03-07，20：14：12 也可以使用以下的方法来设置固定的时间，比如倒计时时间固定从1小时开始 12var endTime=new Date();endTime.setTime(endTime.getTime()+3600*1000); 注意分清var、const和let三个定义变量的区别： var定义的变量可以修改，如果不初始化会输出undefined，不会报错 const定义的变量不可以修改，而且必须初始化 let是块级作用域，函数内部使用let定义后，对函数外部无影响 Moving Clock 让倒计时动起来 使用setInterval()方法更新，从而数字可以变化而更新生成新的小球的位置12345678910111213141516//添加时钟的动画效果setInterval( function()&#123; render(context);//初始化时间 update();//对时间进行更新 &#125;, 50 //一秒有1000毫秒，即20分之1， //所以帧率为20，即动画1秒钟更新20次。但事实上，因为里面的函数执行效率不同，所以帧数不一定为20)``` * `context.clearRect(x,y,canvasWidth,canvasHeight);`其中x,y指的是清除矩形画布的左上角位置，canvasWidth,canvasHeight指的是清除矩形画布的宽度和长度。使用该函数可以让canvas中后来生成的图形不会和原来的图形叠加在一起了，相反效果的是`context.fillRect()`，其作用是填充矩形，参数类似。```jscontext.clearRect(0,0,context.canvas.width,context.canvas.height);//从右上角开始，范围是整个画布//使用context.canvas.width来获取canvas的宽度是context的属性之一 Ball Motion 小球的运动 小球的运动很有趣，和高中物理课上的抛物线一样，有初始速度，重力加速度，摩擦系数。 小球的运动也需要借助setInterval()方法来更新，类似时钟的动画效果 小球触底后反弹使用if语句来判断12345//当小球触底后会反弹if(canvasHeight-ball.y&lt;=ball.r)&#123; ball.y=canvasHeight-ball.r; ball.vy=-ball.vy*0.5;//添加阻力系数&#125; Performance Optimization 及时清空Canvas画布外面的小球 核心是balls[cnt++]=balls[i]这个表达式，我一开始也是有点懵逼。后来做了下试验就明白了。这个表达式的探讨我放在接下的这篇博文中12345678910111213//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//Math.min();两个数取最小值while(balls.length&gt;Math.min(250,cnt))&#123; balls.pop();//删除第cnt个到balls.length-1个数组 //删除前面的数组使用balls.shift();&#125; Clock Effect 将倒计时的效果换成正常时钟效果 *比较简单1var ret=currentTime.getHours()*3600+currentTime.getMinutes()*60+currentTime.getSeconds(); 纯属个人的笔记，看下慕课网的视频是最好理解的哈。如果有什么笔记写错了，麻烦指出，谢谢同学]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript正则表达式基础归纳]]></title>
      <url>%2F2017%2F03%2F05%2F20170305-JavaScript-RegExp%2F</url>
      <content type="text"><![CDATA[归纳包含以下内容：正则表达式简介、工具使用、RegExp对象、元字符、字符类、范围类、JS预定义类、量词、JS正则的贪婪模式和非贪婪模式、分组、前瞻、JS对象属性、test和exec方法、字符串对象方法 正则表达式简介Regular Expression，即正则表达式。使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 工具使用在线显示正则表达式的图形工具^footnote：regexper官网 以下为Sublime使用的三种演示： 首先，在sublime中，使用快捷键ctrl+h打开replace窗口，再点击“*”，这样就可以在Sublime的输入框中输入正则表达式来查找字段 将is这个单词替换成IS待处理字段：123//test.txt//将is这个单词替换成ISthis is a boy 在输入框中输入： 正则表达式图形表示： 成功处理字段： 123//test.txt//将is这个单词替换成ISthis IS a boy 去掉含有jpg后缀的http地址中的http://待处理字段： 1234//去掉含有jpg后缀的http地址中的http://http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 在输入框中输入： 正则表达式图形表示： 备注： 注意符号/要使用\来转义，即\/. 表示any character，任意字符+表示不限量()内是第一个分组 成功处理字段： 1234//去掉含有jpg后缀的http地址中的http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 日期替换，将日期格式如2013-01-13替换成01-13-2013待处理字段：1234//日期替换，将日期格式如2013-01-13替换成01-13-20132014-11-122015/04/0623771/34/22 在输入框中输入： 正则表达式图形表示： 成功处理字段： 1234//日期替换，将日期格式如2013-01-13替换成01-13-201311-2014-1204-2015-0623771/34/22 RegExp对象有两种方法实例化RegExp对象，即字面量和构造函数。 字面量12var reg=/\bis\b/g;&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 构造函数12var reg=new RegExp(&apos;\\bis\\b&apos;,&apos;g&apos;);&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 备注： \要转义 元字符正则表达式由两种基本字符类型组成： 原意文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符：*+?$^.|(){}[] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX 与X对应的控制字符（Ctrl+X） 字符类 一般情况下正则表达式一个字符对应字符串一个字符例如：表达式ab\t的含义是 我们可以使用元字符[]来构建一个简单的类所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符表达式[abc]，即把字符a或b或c归为一类，表达式可以匹配这类的字符字符类取反：[^abc] 范围类 [a-z]，闭区间 [a-zA-Z]，可连写 JS预定义类 预定类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\v\f\r\n] 空白符 \S [^\t\v\f\r\n] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \W [^a-zA-Z_0-9] 非单词字符 备注：空白符为[ \t\n\x0B\f\r]，空字符为\0，\0代表查找NULL字符验证： 边界| 字符 | 含义 ||:———:|:———:|| ^ | 以xxx开始 || $ | 以xxx结束 || \b | 单词边界 || \B | 非单词边界 | 举例： \b，\B的使用 ^$的使用 多行匹配，/m影响的是^$的分割方式 量词 字符 含义 ? 0次或1次（最多一次） + 1次或1次以上（至少一次） * 0次或多次 (任意次) {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现为n次 {0,m} 最多出现m次 举例：1\d?\d+\d*\d&#123;6&#125;\d&#123;3,6&#125;\d&#123;3,&#125;\d&#123;0,6&#125; JS正则的贪婪模式和非贪婪模式 贪婪模式量词为{n,m}时，正则表达式尽可能多得往m匹配 非贪婪模式在量词{n,m}后面加上? 举例： 分组 分组使用()来实现分组：Byron{3}指的是n出现3次；(Byron){3}指的是Byron出现3次 1/Byron&#123;3&#125;(Byron)&#123;3&#125;/ 或使用|来实现或Byron|Casper和Byr(on|Ca)sper 1/Byron|Casper(Byr(on|Ca)sper)/ 反向引用使用$符：将2016-07-13转换为07/13/2016 1&apos;2014/02/23&apos;.replace(/(\d&#123;4&#125;)\/(\d&#123;2&#125;)\/(\d&#123;2&#125;)/g,&apos;$2-$3-$1&apos;); 忽略分组不希望捕获某些分组。只需要在分组内加上?: 1/(?:Byron).(123)/ 前瞻 前瞻就是正则表达式匹配到规则的时候，向前检查是否符合断言。“前”指的是从文本头部到文本尾部的方向 后顾和前瞻方向相反，javascript中不支持 符合断言称为正向匹配或肯定匹配；不符合断言称为负向匹配或否定匹配| 名称 | 正则 ||:————-: |:————-:|| 正向前瞻 | exp(?=assert) || 负向前瞻 | exp(?!assert) | 举例： JS对象属性 global ：全局匹配，默认值为false ignoreCase ：忽略大小写，默认值为false multiline ：多行匹配，默认值为false lastIndex ：当前表达式匹配内容的最后一个字符的下一个位置 source ：正则表达式的文本字符串 备注：global、ignore case、multiline为只读 举例： test和exec方法 test()RegExp.prototype.test(str); 用于测试字符串参数中是否存在匹配正则表达式模式的字符串。可以发现，在全局调用下，即对于reg2，在第三次test匹配时出现了false，这是因为在全局调用下lastIndex不为0。 每次都实例化reg2可以使test匹配时不出现false,但这花费内存开销。所以当我们想用到test本义时，不用加上/g来进行全局匹配 exec() RegExp.prototype.exec(str); 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符位置 input 存放被检索的字符串string 两种调用方式： 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与RegExpObject的第二个子表达式相匹配的文本（如果有的话），以此类推 在非全局调用下，lastIndex不生效，会被正则忽略，默认为0； 全局调用 非全局调用类似，不同的是lastIndex生效 字符串对象方法 search()String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果的index，查找不到返回-1； search()方法不执行全局匹配，它将忽略/g，并且总是从字符串的开始进行检索 备注：对于字符串或数字，search()方法会尝试转化为正则表达式 match()String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp是否具有标志g对结果影响很大 两种调用方式 非全局调用 如果regexp没有标志g，那么match()方法就只能在字符串中执行一次匹配：(1) 如果没有找到任何匹配的文本，将返回null；(2) 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性：(1) index声明匹配文本的起始字符在字符串的位置；(2)input声明对stringObject的引用 备注：与exec()的非全局调用方法类似，只是match()方法是String.prototype.match(reg)，exec()方法是RegExp.prototype.match(str) 全局调用 如果regexp具有标志g，则match()方法将执行全局检索，找到字符串中的所有匹配子字符串：(1) 没有找到任何匹配的字串，则返回null；(2) 如果找到了一个或多个匹配字串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 split()String.prototype.split(reg); 使用字符串或正则表达式来将原字符串分割成字符数组备注： split()方法将字符串转换为对应正则表达式 replace()String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function会在每次匹配替换的时候调用，有四个参数 匹配字符串 (match) 正则表达式分组内容，没有分组则没有改参数 (group1,group2……) 匹配项在字符串中的index (index) 原字符串 (origin) 这篇文章之前是我发在CSDN博客上的，因为又重新做了目前这个，就寻思着再次发布一下O__O “…]]></content>
    </entry>

    
  
  
</search>
