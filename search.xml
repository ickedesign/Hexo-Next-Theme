<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript正则表达式基础归纳]]></title>
      <url>%2F2017%2F03%2F05%2F20170305-JavaScript-RegExp%2F</url>
      <content type="text"><![CDATA[归纳包含以下内容：正则表达式简介、工具使用、RegExp对象、元字符、字符类、范围类、JS预定义类、量词、JS正则的贪婪模式和非贪婪模式、分组、前瞻、JS对象属性、test和exec方法、字符串对象方法 正则表达式简介Regular Expression，即正则表达式。使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 工具使用在线显示正则表达式的图形工具^footnote：regexper官网 以下为Sublime使用的三种演示： 首先，在sublime中，使用快捷键ctrl+h打开replace窗口，再点击“*”，这样就可以在Sublime的输入框中输入正则表达式来查找字段 将is这个单词替换成IS待处理字段：123//test.txt//将is这个单词替换成ISthis is a boy 在输入框中输入： 正则表达式图形表示： 成功处理字段： 123//test.txt//将is这个单词替换成ISthis IS a boy 去掉含有jpg后缀的http地址中的http://待处理字段： 1234//去掉含有jpg后缀的http地址中的http://http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 在输入框中输入： 正则表达式图形表示： 备注： 注意符号/要使用\来转义，即\/. 表示any character，任意字符+表示不限量()内是第一个分组 成功处理字段： 1234//去掉含有jpg后缀的http地址中的http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 日期替换，将日期格式如2013-01-13替换成01-13-2013待处理字段：1234//日期替换，将日期格式如2013-01-13替换成01-13-20132014-11-122015/04/0623771/34/22 在输入框中输入： 正则表达式图形表示： 成功处理字段： 1234//日期替换，将日期格式如2013-01-13替换成01-13-201311-2014-1204-2015-0623771/34/22 RegExp对象有两种方法实例化RegExp对象，即字面量和构造函数。 字面量12var reg=/\bis\b/g;&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 构造函数12var reg=new RegExp(&apos;\\bis\\b&apos;,&apos;g&apos;);&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 备注： \要转义 元字符正则表达式由两种基本字符类型组成： 原意文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符：*+?$^.|(){}[] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX 与X对应的控制字符（Ctrl+X） 字符类 一般情况下正则表达式一个字符对应字符串一个字符例如：表达式ab\t的含义是 我们可以使用元字符[]来构建一个简单的类所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符表达式[abc]，即把字符a或b或c归为一类，表达式可以匹配这类的字符字符类取反：[^abc] 范围类 [a-z]，闭区间 [a-zA-Z]，可连写 JS预定义类 预定类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\v\f\r\n] 空白符 \S [^\t\v\f\r\n] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \W [^a-zA-Z_0-9] 非单词字符 备注：空白符为[ \t\n\x0B\f\r]，空字符为\0，\0代表查找NULL字符验证： 边界| 字符 | 含义 ||:———:|:———:|| ^ | 以xxx开始 || $ | 以xxx结束 || \b | 单词边界 || \B | 非单词边界 | 举例： \b，\B的使用 ^$的使用 多行匹配，/m影响的是^$的分割方式 量词 字符 含义 ? 0次或1次（最多一次） + 1次或1次以上（至少一次） * 0次或多次 (任意次) {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现为n次 {0,m} 最多出现m次 举例：1\d?\d+\d*\d&#123;6&#125;\d&#123;3,6&#125;\d&#123;3,&#125;\d&#123;0,6&#125; JS正则的贪婪模式和非贪婪模式 贪婪模式量词为{n,m}时，正则表达式尽可能多得往m匹配 非贪婪模式在量词{n,m}后面加上? 举例： 分组 分组使用()来实现分组：Byron{3}指的是n出现3次；(Byron){3}指的是Byron出现3次 1/Byron&#123;3&#125;(Byron)&#123;3&#125;/ 或使用|来实现或Byron|Casper和Byr(on|Ca)sper 1/Byron|Casper(Byr(on|Ca)sper)/ 反向引用使用$符：将2016-07-13转换为07/13/2016 1&apos;2014/02/23&apos;.replace(/(\d&#123;4&#125;)\/(\d&#123;2&#125;)\/(\d&#123;2&#125;)/g,&apos;$2-$3-$1&apos;); 忽略分组不希望捕获某些分组。只需要在分组内加上?: 1/(?:Byron).(123)/ 前瞻 前瞻就是正则表达式匹配到规则的时候，向前检查是否符合断言。“前”指的是从文本头部到文本尾部的方向 后顾和前瞻方向相反，javascript中不支持 符合断言称为正向匹配或肯定匹配；不符合断言称为负向匹配或否定匹配| 名称 | 正则 ||:————-: |:————-:|| 正向前瞻 | exp(?=assert) || 负向前瞻 | exp(?!assert) | 举例： JS对象属性 global ：全局匹配，默认值为false ignoreCase ：忽略大小写，默认值为false multiline ：多行匹配，默认值为false lastIndex ：当前表达式匹配内容的最后一个字符的下一个位置 source ：正则表达式的文本字符串 备注：global、ignore case、multiline为只读 举例： test和exec方法 test()RegExp.prototype.test(str); 用于测试字符串参数中是否存在匹配正则表达式模式的字符串。可以发现，在全局调用下，即对于reg2，在第三次test匹配时出现了false，这是因为在全局调用下lastIndex不为0。 ![这里写图片描述](http://img.blog.csdn.net/20170125152324662) - 每次都实例化reg2可以使test匹配时不出现false,但这花费内存开销。 所以当我们想用到test本义时，不用加上/g来进行全局匹配 ![这里写图片描述](http://img.blog.csdn.net/20170125152751892) exec() RegExp.prototype.exec(str); 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符位置 input 存放被检索的字符串string 两种调用方式： 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与RegExpObject的第二个子表达式相匹配的文本（如果有的话），以此类推 在非全局调用下，lastIndex不生效，会被正则忽略，默认为0； 全局调用 非全局调用类似，不同的是lastIndex生效 字符串对象方法 search()String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果的index，查找不到返回-1； search()方法不执行全局匹配，它将忽略/g，并且总是从字符串的开始进行检索 备注：对于字符串或数字，search()方法会尝试转化为正则表达式 match()String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp是否具有标志g对结果影响很大 两种调用方式 非全局调用 如果regexp没有标志g，那么match()方法就只能在字符串中执行一次匹配：(1) 如果没有找到任何匹配的文本，将返回null；(2) 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性：(1) index声明匹配文本的起始字符在字符串的位置；(2)input声明对stringObject的引用 备注：与exec()的非全局调用方法类似，只是match()方法是String.prototype.match(reg)，exec()方法是RegExp.prototype.match(str) 全局调用 如果regexp具有标志g，则match()方法将执行全局检索，找到字符串中的所有匹配子字符串：(1) 没有找到任何匹配的字串，则返回null；(2) 如果找到了一个或多个匹配字串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 split()String.prototype.split(reg); 使用字符串或正则表达式来将原字符串分割成字符数组备注： split()方法将字符串转换为对应正则表达式 replace()String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function会在每次匹配替换的时候调用，有四个参数 匹配字符串 (match) 正则表达式分组内容，没有分组则没有改参数 (group1,group2……) 匹配项在字符串中的index (index) 原字符串 (origin) 这篇文章之前是我发在CSDN博客上的，因为又重新做了目前这个，就寻思着再次发布一下O__O “…]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[测试]next的内置标签]]></title>
      <url>%2F2017%2F03%2F04%2FtestThird%2F</url>
      <content type="text"><![CDATA[人的一切痛苦，本质上是对自己的无能的愤怒 王小波 这是文本内容╮(╯▽╰)╭测试文本，测试完毕~]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转载]ES5, ES6, ES2016, ES.Next: What's going on with JavaScript versioning?]]></title>
      <url>%2F2017%2F03%2F04%2FtestSecond%2F</url>
      <content type="text"><![CDATA[JavaScript 有着很奇怪的命名史。 1995 年，它作为网景浏览器（Netscape Navigator）的一部分首次发布，网景给这个新语言命名为 LiveScript。一年后，为了搭上当时媒体热炒 Java 的顺风车，临时改名为了 JavaScript （当然，Java 和 JavaScript 的关系，就和雷锋和雷锋塔一样 —— 并没有什么关系） 歪果仁的笑话怎么一点都不好笑 译者注：wikipedia 的 JavaScript 词条 更详细的叙述了这段历史 1996 年，网景将 JavaScript 提交给 ECMA International（欧洲计算机制造商协会） 进行标准化，并最终确定出新的语言标准，它就是 ECMAScript。自此，ECMAScript 成为所有 JavaScript 实现的基础，不过，由于 JavaScript 名字的历史原因和市场原因（很显然 ECMAScript 这个名字并不令人喜欢……），现实中我们只用 ECMAScript 称呼标准，平时都还是使用 JavaScript 来称呼这个语言。 术语（译者注）： 标准（Standard）： 用于定义与其他事物区别的一套规则 实现（Implementation）： 某个标准的具体实施/真实实践 不过，JavaScript 开发者们并不怎么在乎这些，因为在诞生之后的 15 年里，ECMAScript 并没有多少变化，而且现实中的很多实现都已经和标准大相径庭。其实在第一版的 ECMAScript 发布后，很快又跟进发布了两个版本，但是自从 1999 年 ECMAScript 3 发布后，十年内都没有任何改动被成功添加到官方规范里。取而代之的，是各大浏览器厂商们争先进行自己的语言拓展，web 开发者们别无选择只能去尝试并且支持这些 API。即使是在 2009 年 ECMAScript 5 发布之后，仍然用了数年这些新规范才得到了浏览器的广泛支持，可是大部分开发者还是写着 ECMAScript 3 风格的代码，并不觉得有必要去了解这些规范。 译者注：ECMAScript 第四版草案由于太过激进而被抛弃，Adobe 的 ActionScript 3.0 是 ECMAScript edition 4 的唯一实现（ Flash 差点就统一 Web 了） 到了 2012 年，事情突然开始有了转变。大家开始推动停止对旧版本 IE 浏览器的支持，用 ECMAScript 5 (ES5) 风格来编写代码也变得更加可行。与此同时，一个新的 ECMAScript 规范也开始启动。到了这时，大家开始逐渐习惯以对 ECMAScript 规范的版本支持程度来形容各种 JavaScript 实现。在正式被指名为 ECMAScript 第 6 版 (ES6) 之前，这个新的标准原本被称为 ES.Harmony（和谐）。2015 年，负责制定 ECMAScript 规范草案的委员会 TC39 决定将定义新标准的制度改为一年一次，这意味着每个新特性一旦被批准就可以添加，而不像以往一样，规范只有在整个草案完成，所有特性都没问题后才能被定稿。因此，ECMAScript 第 6 版在六月份公布之前，又被重命名为了 ECMAScript 2015（ES2015） 目前，仍然有很多新的 JavaScript 特性或语法正在提议中，包括 decorators（装饰者），async-await（async-await 异步编程模型） 和 static class properties（静态类属性）。它们通常被称为 ES7，ES2016 或者 ES.Next 的特性，不过实际上它们只能被称作提案或者说可能性，毕竟 ES2016 的规范还没有完成，有可能全部都会引入，也有可能一个都没有。TC39 把一个提案分为 4 个阶段，你可以在 Babel 的官网 上查看各个提案目前都在哪个阶段了。 所以，我们该如何使用这一大堆术语呢？下面的列表或许能帮助到你： ECMAScript：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。 JavaScript：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。 ECMAScript 5 (ES5)：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。 ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅这张兼容性表来查看不同浏览器和工具的实现情况。 ECMAScript 2016：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定 ECMAScript Proposals：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。 在这整个 Blog 中，我将把目前的 ECMAScript 版本称作 ES6（因为这是大部分开发者最习以为常的），把明年的规范称作 ES2016（因为，与 ES6/ES2015 不同，这个名字将在整个标准化过程中沿用）并且将那些还没有成为 ECMAScript 定稿或草案的未来语言概念称为 ECMAScript 提案或者 JavaScript 提案。我将尽我所能在任何可能引起困惑的场合沿用这篇文章。 一些资源 TC39 的 Github 仓库上可以看到所有目前公开的提案 如果你还不熟悉 ES6，Babel 有一个很不错的特性概览 如果你希望深入 ES6，这里有两本很不错的书： Axel Rauschmayer 的 Exploring ES6和 Nicholas Zakas 的 Understanding ECMAScript 6。Axel 的博客 2ality 也是很不错的 ES6 资源 著作权声明本文译自 ES5, ES6, ES2016, ES.Next: What’s going on with JavaScript versioning?译者 黄玄，首次发布于 Hux Blog，转载请保留以上链接]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[[转载]CommonJS，RequireJS，SeaJS 归纳笔记]]></title>
      <url>%2F2016%2F03%2F04%2FtestFirst%2F</url>
      <content type="text"><![CDATA[Foreword Here comes Module! 随着网站逐渐变成「互联网应用程序」，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试……我们不得不使用软件工程的方法，来管理网页的业务逻辑。 于是，JavaScript 的模块化成为迫切需求。在 ES6 Module 来临之前，JavaScript 社区提供了强大支持，尝试在现有的运行环境下，实现模块的效果。 Catalog CommonJS &amp; Node History RequireJS &amp; AMD SeaJS &amp; CMD AMD vs CMD WebPack CommonJS &amp; Node Javascript: not just for browsers any more! —— CommonJS Slogen 前端模块化的事实标准之一，2009 年 8 月，CommonJS 诞生。 CommonJS 本质上只是一套规范（API 定义），而 Node.js 采用并实现了部分规范，CommonJS Module 的写法也因此广泛流行。 让我们看看 Node 中的实现： 123456789// 由于 Node 原生支持模块的作用域，并不需要额外的 wrapper// "as though the module was wrapped in a function"var a = require('./a') // 加载模块（同步加载）a.doSomething() // 等上一句执行完才会执行exports.b = function()&#123; // 暴露 b 函数接口 // do something&#125; exports是一个内置对象，就像require是一个内置加载函数一样。如果你希望直接赋值一个完整的对象或者构造函数，覆写module.exports就可以了。 CommonJS 前身叫 ServerJS ，后来希望能更加 COMMON，成为通吃各种环境的模块规范，改名为 CommonJS 。CommonJS 最初只专注于 Server-side 而非浏览器环境，因此它采用了同步加载的机制，这对服务器环境（硬盘 I/O 速度）不是问题，而对浏览器环境（网速）来说并不合适。 因此，各种适用于浏览器环境的模块框架与标准逐个诞生，他们的共同点是： 采用异步加载（预先加载所有依赖的模块后回调执行，符合浏览器的网络环境） 虽然代码风格不同，但其实都可以看作 CommonJS Modules 语法的变体。 都在向着 COMMON 的方向进化：兼容不同风格，兼容浏览器和服务器两种环境 本文接下来要讨论的典例是： RequireJS &amp; AMD（异步加载，预执行，依赖前置。默认推荐 AMD 写法） SeaJS &amp; CMD（异步加载，懒执行，依赖就近，默认推荐 CommonJS 写法） History 此段落参考自玉伯的 前端模块化开发那点历史 09-10 年间，CommonJS（那时还叫 ServerJS） 社区推出 Modules/1.0 规范，并且在 Node.js 等环境下取得了很不错的实践。 09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到浏览器端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派： Modules/1.x 流派。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增 Modules/Transport 规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的 component 和走在前沿的 es6 module transpiler。 Modules/Async 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是 AMD 规范及其实现 RequireJS。这个稍后再细说。 Modules/2.0 流派。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是 BravoJS 和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份 Modules/2.0-draft 规范花了很多心思。FlyScript 的作者提出了 Modules/Wrappings 规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个观点在本文中的典型代表就是 SeaJS 和 CMD 了 补一嘴：阿里 KISSY 的 KMD 其实跟 AMD 非常类似，只是用 add和use 两个源自于 YUI Modules 的函数名替换了 define 和 require ，但其原理更接近 RequireJS ，与 YUI Modules 的 Y 沙箱 Attach 机制并不相同 RequireJS &amp; AMDAMD (Async Module Definition) 是 RequireJS 在推广过程中对模块定义的规范化产出。 RequireJS is a JavaScript file and module loader. It is optimized for in-browser use, but it can be used in other JavaScript environments RequireJS 主要解决的还是 CommonJS 同步加载脚本不适合浏览器 这个问题： 123456789101112//CommonJSvar Employee = require("types/Employee");function Programmer ()&#123; //do something&#125; Programmer.prototype = new Employee();//如果 require call 是异步的，那么肯定 error//因为在执行这句前 Employee 模块肯定来不及加载进来 As the comment indicates above, if require() is async, this code will not work. However, loading scripts synchronously in the browser kills performance. So, what to do? 所以我们需要 Function Wrapping 来获取依赖并且提前通过 script tag 提前加载进来 1234567891011121314//AMD Wrapperdefine( [types/Employee], //依赖 function(Employee)&#123; //这个回调会在所有依赖都被加载后才执行 function Programmer()&#123; //do something &#125;; Programmer.prototype = new Employee(); return Programmer; //return Constructor &#125;) 当依赖模块非常多时，这种依赖前置的写法会显得有点奇怪，所以 AMD 给了一个语法糖， simplified CommonJS wrapping，借鉴了 CommonJS 的 require 就近风格，也更方便对 CommonJS 模块的兼容： 123456define(function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); The AMD loader will parse out the require(&#39;&#39;) calls by using Function.prototype.toString(), then internally convert the above define call into this: 123456define(['require', 'dependency1', 'dependency2'], function (require) &#123; var dependency1 = require('dependency1'), dependency2 = require('dependency2'); return function () &#123;&#125;;&#125;); 出于Function.prototype.toString()兼容性和性能的考虑，最好的做法还是做一次 optimized build AMD 和 CommonJS 的核心争议如下： 1. 执行时机Modules/1.0: 1var a = require("./a") // 执行到此时，a.js 才同步下载并执行 AMD: （使用 require 的语法糖时） 12345define(["require"],function(require))&#123; // 在这里，a.js 已经下载并且执行好了 // 使用 require() 并不是 AMD 的推荐写法 var a = require("./a") // 此处仅仅是取模块 a 的 exports&#125;) AMD 里提前下载 a.js 是出于对浏览器环境的考虑，只能采取异步下载，这个社区都认可（Sea.js 也是这么做的） 但是 AMD 的执行是 Early Executing，而 Modules/1.0 是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的人也不能接受。 2. 书写风格AMD 推荐的风格并不使用require，而是通过参数传入，破坏了依赖就近： 12345define(["a", "b", "c"],function(a, b, c)&#123; // 提前申明了并初始化了所有模块 true || b.foo(); //即便根本没用到模块 b，但 b 还是提前执行了。&#125;) 不过，在笔者看来，风格喜好因人而异，主要还是预执行和懒执行的差异。 另外，require 2.0 也开始思考异步处理软依赖（区别于一定需要的硬依赖）的问题，提出了这样的方案： 123456// 函数体内：if(status)&#123; async(['a'],function(a)&#123; a.doSomething() &#125;)&#125; SeaJS &amp; CMDCMD (Common Module Definition) 是 SeaJS 在推广过程中对模块定义的规范化产出，是 Modules/2.0 流派的支持者，因此 SeaJS 的模块写法尽可能与 Modules/1.x 规范保持一致。 不过目前国外的该流派都死得差不多了，RequireJS 目前成为浏览器端模块的事实标准，国内最有名气的就是玉伯的 Sea.js ，不过对国际的推广力度不够。 CMD Specification English (CMDJS-repo) Chinese (SeaJS-repo) CMD 主要有 define, factory, require, export 这么几个东西 define define(id?, deps?, factory) factory factory(require, exports, module) require require(id) exports Object CMD 推荐的 Code Style 是使用 CommonJS 风格的 require： 这个 require 实际上是一个全局函数，用于加载模块，这里实际就是传入而已 12345678910111213define(function(require, exports) &#123; // 获取模块 a 的接口 var a = require('./a'); // 调用模块 a 的方法 a.doSomething(); // 对外提供 foo 属性 exports.foo = 'bar'; // 对外提供 doSomething 方法 exports.doSomething = function() &#123;&#125;;&#125;); 但是你也可以使用 AMD 风格，或者使用 return 来进行模块暴露 1234567891011define('hello', ['jquery'], function(require, exports, module) &#123; // 模块代码... // 直接通过 return 暴露接口 return &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); Sea.js 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的 module.declare 改名为 define 等。Sea.js 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。 AMD vs CMD虽然两者目前都兼容各种风格，但其底层原理并不相同，从其分别推荐的写法就可以看出两者背后原理的不同： 对于依赖的模块，AMD 是提前执行，CMD 是懒执行。（都是先加载） CMD 推崇依赖就近，AMD 推崇依赖前置。 看代码： 12345678// AMD 默认推荐define(['./a', './b'], function(a, b) &#123; // 依赖前置，提前执行 a.doSomething() b.doSomething()&#125;) 12345678910// CMDdefine(function(require, exports, module) &#123; var a = require('./a') a.doSomething() var b = require('./b') // 依赖就近，延迟执行 b.doSomething()&#125;) WebPack working… 著作权声明译者 黄玄，首次发布于 Hux Blog，转载请保留以上链接]]></content>
    </entry>

    
  
  
</search>
