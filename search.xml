<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[CSS易混淆点小总结]]></title>
      <url>%2F2017%2F03%2F12%2F20170312-CSS-Study-CSS-Layout%2F</url>
      <content type="text"><![CDATA[总结包含以下内容：CSS hack、Flex布局、Box-Sizing、清除浮动、水平垂直居中、em和rem的区别、max-width、@media媒体查询、CSS伪元素、column 大家想更好学习CSS布局的话，可以看看阮一峰老师和张鑫旭老师的博客。本文是看完学习CSS布局做的一些小总结，还加入了自己之前有点懵的布局方面的知识。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[关于arr[i++]与arr[++i]]]></title>
      <url>%2F2017%2F03%2F10%2F20170310-JavaScript-arr%5Bi%2B%2B%5D%2F</url>
      <content type="text"><![CDATA[前言 前几天做Canvas倒计时的时候，慕课网的老师讲到了一个及时清除不在画布中的小球的做法。以下是实现代码： 123456789101112//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//删除前面的数组使用balls.shift()while(balls.length&gt;cnt)&#123; balls.pop();//删除第cnt个到balls.length-1个数组&#125; 一开始挺懵的，arr[i++]是啥(ﾟｰﾟ)，于是开始一步一步地探索 i++和++i大一的时候上java课，老师讲过了这样的题，想必学过计算机相关的都知道&nbsp; &nbsp; (/▽╲) 1234567891011var a=1;var b=2;a=b++;console.log("a的值是："+a+"，"+"b的值是："+b);//"a的值是：2，b的值是：3"var c=1;var d=2;c=++d;console.log("c的值是："+c+"，"+"d的值是："+d);//"c的值是：3，d的值是：3" a=b++是b先把值赋给a，自身再加1；a=++b是b先自身加1，再把值赋给a i++和++i&nbsp; 在循环中的区别 i++在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(i++); //依次输出0,2,4&#125; ++i在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(++i); //依次输出1,3,5&#125; 对比以上代码，是不是发现什么了&nbsp; &nbsp; (ﾟｰﾟ) arr[i++]和arr[++i]在循环中的区别 arr[i++]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[i++]); //依次输出11,13,15&#125; arr[++i]在循环中的输出： 123456var arr=[11,12,13,14,15,16];for(var i=0;i&lt;arr.length;i++)&#123; console.log(arr[++i]); //依次输出12,14,16&#125; 如果数组是奇数个，那么输出arr[++i]的最后一个数会是一个undefined &nbsp; &nbsp; (¯﹃¯) arr[i++]+=1和arr[++i]+=1在循环中的区别 arr[i++]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[i++]+=1;&#125; console.log(arr);//输出[2,2,4] arr[++i]+=1在循环中的输出： 1234567var arr=[1,2,3];for(var i=0;i&lt;arr.length;i++)&#123; arr[++i]+=1;&#125; console.log(arr);//输出[1,3,3,NaN] 由于数组是奇数个，所以最后arr[++i]+=1最后的输出结果是NaN，可以通过以下的代码验证 12console.log(undefined+1);//输出NaN 好啦，到此为止，是不是理解了arr[i++]和arr[++i]了，现在回到我们的前言了，老师如何清除不符合判断语句的数组 arr[i++]的使用12345678910111213141516171819202122232425262728var arr=[ &#123;x: 1&#125;, &#123;x: 5&#125;, &#123;x: 9&#125;, &#123;x: 3&#125;, &#123;x: 10&#125;, &#123;x: 6&#125;]var cnt=0;for(var i=0;i&lt;arr.length;i++)&#123; if(arr[i].x&lt;4)&#123; arr[cnt++]=arr[i]; console.log('cnt的值是'+cnt+'，i的值是'+i); //"cnt的值是1，i的值是0" //"cnt的值是2，i的值是3" &#125; &#125; while(arr.length&gt;cnt)&#123; arr.pop();&#125;console.log(arr);// [// [object Object] &#123;x: 1&#125;, // [object Object] &#123;x: 3&#125;// ] 这说明了第0到cnt-1个留在arr中，cnt到arr.length-1的数组删除，使用这个方法就可以来去除不符合判断语句的数组了，是不是一个很好的技巧呢 有些我学得还不深，关于i++在循环中的输出也是有点懵，不过我知道过程是啥。梳理一下呗，同学有什么想法么&nbsp; &nbsp; __φ(．．;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas绚丽倒计时学习笔记]]></title>
      <url>%2F2017%2F03%2F09%2F20170309-Canvas-Countdown%2F</url>
      <content type="text"><![CDATA[演示(ˉ▽￣～) &nbsp; &nbsp; |&nbsp; &nbsp; 文件(,,• ₃ •,,)&nbsp; &nbsp; |&nbsp; &nbsp;汁源╭( ･ㅂ･)و ̑̑ Foreword 关于Canvas HTML5 &lt;canvas&gt; 标签用于绘制图像（通过脚本，通常是 JavaScript）。不过，&lt;canvas&gt;元素本身并没有绘制能力（它仅仅是图形的容器）， 您必须使用脚本来完成实际的绘图任务。&nbsp;&nbsp;[该叙述来自W3CSCHOOL] Creat Canvas 创建画布 canvas是行内元素，有默认的高宽（300px*150px） display: block可以把&lt;canvas&gt;&lt;/canvas&gt;变成块级元素,从而可以通过margin: 0 auto;设置为水平居中 &nbsp;&nbsp; o(￣▽￣)ブ（水平居中的其中一种方法） canvas有显示的大小，还有内里分辨率的大小，所以不能在css中设置canvas的宽高。可以使用以下两种方法设置 12&lt;!--直接在标签头设置--&gt;&lt;canvas width="1024" height="500"&gt;&lt;/canvas&gt; 1234//在js中设置var canvas=document.getElementById('canvas');canvas.width="1024";canvas.height="500"; &lt;canvas&gt;是HTML5的新标签，所以存在兼容问题。注意：若把判断条件改成canvas.getContext(&quot;2d&quot;)会出错 123456if(canvas.getContext)&#123; var context=canvas.getContext('2d'); &#125;else&#123; alert('当前浏览器不支持canvas，请更换浏览器后再试');&#125; Draw Line 绘制直线 以下的context，默认由var context=canvas.getContext(&quot;2d&quot;)取得。备注：除了2d绘图，还有3d绘图哦&nbsp; &nbsp; (ˉ▽￣～) context.closePath()的存在会让未闭合的线条自动闭合，所以用不用看情况。总之，一个Canvas画布如果没有使用context.beginPath()，那么画布上的其它图形会受到影响 context.moveTo(x1,y1)用来定义画笔的起始位置context.lineTo(x2,y2)用来定义画笔的终止位置 1234567//画一个闭合图形context.beginPath();context.moveTo(x1,y1);context.lineTo(x2,y2);context.lineTo(x1,y2);context.moveTo(x1,y1);context.closePath(); context.lineWidth=num定义画笔大小context.strokeStyle=&quot;color&quot;定义画笔颜色context.stroke() 执行绘图的方法context.fillStyle=&quot;color&quot;定义填充的颜色context.fill() 执行着色的方法 使用以上方法，即可绘制一个七巧板： Draw Arc 绘制弧线 context.arc(300,300,0,1.5*Math.PI,false) 的含义是沿顺时针的方向来绘制一个圆心为（300，300），角度为1.5π 12context.arc(centerx,centery,radius,startingAngle,endingAngle,anticlockwise=false);//默认clockwise=false，即在逆时针的方向上以角度为 0,0.5*PI,1*PI,1.5*PI,2*PI这种形式绘图 Draw Digit 绘制静止的时钟 先编写一个三维数组，来显示数字和冒号。这里以0和：来举例 12345678910111213141516171819202122232425262728//数字有7列10行组成，冒号由4列10行组成，数组中有1的地方就是代表有小球digit = [ [ [0,0,1,1,1,0,0], [0,1,1,0,1,1,0], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [1,1,0,0,0,1,1], [0,1,1,0,1,1,0], [0,0,1,1,1,0,0] ],//0 [ [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0], [0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0] ]//: ]; 通过循环数组，定义好小球之间的距离，即可画出小球。不过说得容易，逻辑对我们这些初学者有点小复杂。感兴趣可以看下我github上的文件：drawDigit.js Countdown Effect 设置倒计时效果 获取倒计时的时间使用设置好的时间减去现在的时间，这个设置好的时间可以使用new Date()生成，比如const endTime=new Date(2017,2,7,20,14,12)。其中月份是从0开始的，所以这个时间的含义是2017-03-07，20：14：12 也可以使用以下的方法来设置固定的时间，比如倒计时时间固定从1小时开始 12var endTime=new Date();endTime.setTime(endTime.getTime()+3600*1000); 注意分清var、const和let三个定义变量的区别： var定义的变量可以修改，如果不初始化会输出undefined，不会报错 const定义的变量不可以修改，而且必须初始化 let是块级作用域，函数内部使用let定义后，对函数外部无影响 Moving Clock 让倒计时动起来 使用setInterval()方法更新，从而数字可以变化而更新生成新的小球的位置12345678910111213141516//添加时钟的动画效果setInterval( function()&#123; render(context);//初始化时间 update();//对时间进行更新 &#125;, 50 //一秒有1000毫秒，即20分之1， //所以帧率为20，即动画1秒钟更新20次。但事实上，因为里面的函数执行效率不同，所以帧数不一定为20)``` * `context.clearRect(x,y,canvasWidth,canvasHeight);`其中x,y指的是清除矩形画布的左上角位置，canvasWidth,canvasHeight指的是清除矩形画布的宽度和长度。使用该函数可以让canvas中后来生成的图形不会和原来的图形叠加在一起了，相反效果的是`context.fillRect()`，其作用是填充矩形，参数类似。```jscontext.clearRect(0,0,context.canvas.width,context.canvas.height);//从右上角开始，范围是整个画布//使用context.canvas.width来获取canvas的宽度是context的属性之一 Ball Motion 小球的运动 小球的运动很有趣，和高中物理课上的抛物线一样，有初始速度，重力加速度，摩擦系数。 小球的运动也需要借助setInterval()方法来更新，类似时钟的动画效果 小球触底后反弹使用if语句来判断12345//当小球触底后会反弹if(canvasHeight-ball.y&lt;=ball.r)&#123; ball.y=canvasHeight-ball.r; ball.vy=-ball.vy*0.5;//添加阻力系数&#125; Performance Optimization 及时清空Canvas画布外面的小球 核心是balls[cnt++]=balls[i]这个表达式，我一开始也是有点懵逼。后来做了下试验就明白了。这个表达式的探讨我放在接下的这篇博文中&nbsp; &nbsp; (・-・*)12345678910111213//及时清空跳出画布的小球，优化页面的内存var cnt=0for(var i=0;i&lt;balls.length;i++)&#123; if(balls[i].x+radius&gt;0&amp;&amp;balls[i].x-radius&lt;canvasWidth)&#123; //小球数组中的第0个到cnt-1个是在canvas画布中 balls[cnt++]=balls[i]; &#125;&#125;//Math.min();两个数取最小值while(balls.length&gt;Math.min(250,cnt))&#123; balls.pop();//删除第cnt个到balls.length-1个数组 //删除前面的数组使用balls.shift();&#125; Clock Effect 将倒计时的效果换成正常时钟效果 *比较简单1var ret=currentTime.getHours()*3600+currentTime.getMinutes()*60+currentTime.getSeconds(); 纯属个人的笔记，看下慕课网的视频是最好理解的哈。如果有什么笔记写错了，麻烦指出，谢谢同学&nbsp; &nbsp; (o゜▽゜)o☆[BINGO!]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript正则表达式基础归纳]]></title>
      <url>%2F2017%2F03%2F05%2F20170305-JavaScript-RegExp%2F</url>
      <content type="text"><![CDATA[归纳包含以下内容：正则表达式简介、工具使用、RegExp对象、元字符、字符类、范围类、JS预定义类、量词、JS正则的贪婪模式和非贪婪模式、分组、前瞻、JS对象属性、test和exec方法、字符串对象方法 正则表达式简介Regular Expression，即正则表达式。使用单个字符串来描述、匹配一系列符合某个句法规则的字符串。 工具使用在线显示正则表达式的图形工具^footnote：regexper官网 以下为Sublime使用的三种演示： 首先，在sublime中，使用快捷键ctrl+h打开replace窗口，再点击“*”，这样就可以在Sublime的输入框中输入正则表达式来查找字段 将is这个单词替换成IS待处理字段：123//test.txt//将is这个单词替换成ISthis is a boy 在输入框中输入： 正则表达式图形表示： 成功处理字段： 123//test.txt//将is这个单词替换成ISthis IS a boy 去掉含有jpg后缀的http地址中的http://待处理字段： 1234//去掉含有jpg后缀的http地址中的http://http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 在输入框中输入： 正则表达式图形表示： 备注： 注意符号/要使用\来转义，即\/. 表示any character，任意字符+表示不限量()内是第一个分组 成功处理字段： 1234//去掉含有jpg后缀的http地址中的http://www.baidu.com/abc.jpghttp://www.baidu.com/abc.pnghttps://www.baidu.com/abc.jpg 日期替换，将日期格式如2013-01-13替换成01-13-2013待处理字段：1234//日期替换，将日期格式如2013-01-13替换成01-13-20132014-11-122015/04/0623771/34/22 在输入框中输入： 正则表达式图形表示： 成功处理字段： 1234//日期替换，将日期格式如2013-01-13替换成01-13-201311-2014-1204-2015-0623771/34/22 RegExp对象有两种方法实例化RegExp对象，即字面量和构造函数。 字面量12var reg=/\bis\b/g;&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 构造函数12var reg=new RegExp(&apos;\\bis\\b&apos;,&apos;g&apos;);&apos;He is a boy.This is a dog&apos;.replace(reg,&apos;IS&apos;); 备注： \要转义 元字符正则表达式由两种基本字符类型组成： 原意文本字符 元字符 元字符是在正则表达式中有特殊含义的非字母字符：*+?$^.|(){}[] 字符 含义 \t 水平制表符 \v 垂直制表符 \n 换行符 \r 回车符 \0 空字符 \f 换页符 \cX 与X对应的控制字符（Ctrl+X） 字符类 一般情况下正则表达式一个字符对应字符串一个字符例如：表达式ab\t的含义是 我们可以使用元字符[]来构建一个简单的类所谓类是指符合某些特性的对象，一个泛指，而不是特指某个字符表达式[abc]，即把字符a或b或c归为一类，表达式可以匹配这类的字符字符类取反：[^abc] 范围类 [a-z]，闭区间 [a-zA-Z]，可连写 JS预定义类 预定类 字符 等价类 含义 . [^\r\n] 除了回车符和换行符之外的所有字符 \d [0-9] 数字字符 \D [^0-9] 非数字字符 \s [\t\v\f\r\n] 空白符 \S [^\t\v\f\r\n] 非空白符 \w [a-zA-Z_0-9] 单词字符（字母、数字下划线） \W [^a-zA-Z_0-9] 非单词字符 备注：空白符为[ \t\n\x0B\f\r]，空字符为\0，\0代表查找NULL字符验证： 边界| 字符 | 含义 ||:———:|:———:|| ^ | 以xxx开始 || $ | 以xxx结束 || \b | 单词边界 || \B | 非单词边界 | 举例： \b，\B的使用 ^$的使用 多行匹配，/m影响的是^$的分割方式 量词 字符 含义 ? 0次或1次（最多一次） + 1次或1次以上（至少一次） * 0次或多次 (任意次) {n} 出现n次 {n,m} 出现n次到m次 {n,} 至少出现为n次 {0,m} 最多出现m次 举例：1\d?\d+\d*\d&#123;6&#125;\d&#123;3,6&#125;\d&#123;3,&#125;\d&#123;0,6&#125; JS正则的贪婪模式和非贪婪模式 贪婪模式量词为{n,m}时，正则表达式尽可能多得往m匹配 非贪婪模式在量词{n,m}后面加上? 举例： 分组 分组使用()来实现分组：Byron{3}指的是n出现3次；(Byron){3}指的是Byron出现3次 1/Byron&#123;3&#125;(Byron)&#123;3&#125;/ 或使用|来实现或Byron|Casper和Byr(on|Ca)sper 1/Byron|Casper(Byr(on|Ca)sper)/ 反向引用使用$符：将2016-07-13转换为07/13/2016 1&apos;2014/02/23&apos;.replace(/(\d&#123;4&#125;)\/(\d&#123;2&#125;)\/(\d&#123;2&#125;)/g,&apos;$2-$3-$1&apos;); 忽略分组不希望捕获某些分组。只需要在分组内加上?: 1/(?:Byron).(123)/ 前瞻 前瞻就是正则表达式匹配到规则的时候，向前检查是否符合断言。“前”指的是从文本头部到文本尾部的方向 后顾和前瞻方向相反，javascript中不支持 符合断言称为正向匹配或肯定匹配；不符合断言称为负向匹配或否定匹配| 名称 | 正则 ||:————-: |:————-:|| 正向前瞻 | exp(?=assert) || 负向前瞻 | exp(?!assert) | 举例： JS对象属性 global ：全局匹配，默认值为false ignoreCase ：忽略大小写，默认值为false multiline ：多行匹配，默认值为false lastIndex ：当前表达式匹配内容的最后一个字符的下一个位置 source ：正则表达式的文本字符串 备注：global、ignore case、multiline为只读 举例： test和exec方法 test()RegExp.prototype.test(str); 用于测试字符串参数中是否存在匹配正则表达式模式的字符串。可以发现，在全局调用下，即对于reg2，在第三次test匹配时出现了false，这是因为在全局调用下lastIndex不为0。 每次都实例化reg2可以使test匹配时不出现false,但这花费内存开销。所以当我们想用到test本义时，不用加上/g来进行全局匹配 exec() RegExp.prototype.exec(str); 使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果 如果没有匹配的文本则返回null，否则返回一个结果数组： index 声明匹配文本的第一个字符位置 input 存放被检索的字符串string 两种调用方式： 非全局调用 调用非全局的RegExp对象的exec()时，返回数组 第一个元素是与正则表达式相匹配的文本 第二个元素是与RegExpObject的第一个子表达式相匹配的文本（如果有的话） 第三个元素是与RegExpObject的第二个子表达式相匹配的文本（如果有的话），以此类推 在非全局调用下，lastIndex不生效，会被正则忽略，默认为0； 全局调用 非全局调用类似，不同的是lastIndex生效 字符串对象方法 search()String.prototype.search(reg) search()方法用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串 方法返回第一个匹配结果的index，查找不到返回-1； search()方法不执行全局匹配，它将忽略/g，并且总是从字符串的开始进行检索 备注：对于字符串或数字，search()方法会尝试转化为正则表达式 match()String.prototype.match(reg) match()方法将检索字符串，以找到一个或多个与regexp匹配的文本 regexp是否具有标志g对结果影响很大 两种调用方式 非全局调用 如果regexp没有标志g，那么match()方法就只能在字符串中执行一次匹配：(1) 如果没有找到任何匹配的文本，将返回null；(2) 否则它将返回一个数组，其中存放了与它找到的匹配文本有关的信息 返回数组的第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本 除了常规的数组元素之外，返回的数组还含有2个对象属性：(1) index声明匹配文本的起始字符在字符串的位置；(2)input声明对stringObject的引用 备注：与exec()的非全局调用方法类似，只是match()方法是String.prototype.match(reg)，exec()方法是RegExp.prototype.match(str) 全局调用 如果regexp具有标志g，则match()方法将执行全局检索，找到字符串中的所有匹配子字符串：(1) 没有找到任何匹配的字串，则返回null；(2) 如果找到了一个或多个匹配字串，则返回一个数组 数组元素中存放的是字符串中所有的匹配子串，而且也没有index属性或input属性 split()String.prototype.split(reg); 使用字符串或正则表达式来将原字符串分割成字符数组备注： split()方法将字符串转换为对应正则表达式 replace()String.prototype.replace String.prototype.replace(str,replaceStr) String.prototype.replace(reg,replaceStr) String.prototype.replace(reg,function) function会在每次匹配替换的时候调用，有四个参数 匹配字符串 (match) 正则表达式分组内容，没有分组则没有改参数 (group1,group2……) 匹配项在字符串中的index (index) 原字符串 (origin) 这篇文章之前是我发在CSDN博客上的，因为又重新做了目前这个，就寻思着再次发布一下O__O “…]]></content>
    </entry>

    
  
  
</search>
